# **4.4 Viewing log messages**

So far, we’ve said quite a bit about how to create log messages, but very little about where
those messages actually go. There are actually three different destinations for log messa-
ges: Each log message can appear as output on the console, as a message on the rosout topic, 
and as an entry in a log file. Let’s see how to use each of these.

## **4.4.1 Console**

First, and most visibly, log messages are sent to the console. Specifically, DEBUG and
INFO messages are printed on standard output, whereas WARN, ERROR, and FATAL
messages are sent to standard error.Í3

```
/-The distinction here between standard output and standard error is basically irrelevant, unless you want to redirect one or both of these streams to a file or a pipe, in
/which case it causes some complications. The usual file redirection technique<br>
/
/      command > file<br>
/
/redirects standard output, but not standard error. To capture all of the log messages
/to the same file, use something like this instead:<br>
/
/      command &> file<br>
/
/Be careful, however, because differences in the way these two streams are buffered
/can cause the messages to appear out of order—with DEBUG and INFO messages
/appearing later than one might expect—in the result. You can force the messages
/into their natural order by using the stdbuf command to convince standard output
/to use line buffering:<br>
/
/      stdbuf -oL command &> file<br>
/
/Finally, note that ROS inserts ANSI color codes—which look, to humans and to software that does not understand them, something like this: ˆ[[0m—into its output,
/even if the output is not being directed to a terminal. To view a file containing these
/sorts of codes, try a command like this:<br>
/
/      less -r file<br>
```
      
**Formatting** console messages** You can tweak the format used to print log messages on
the console by setting the ROSCONSOLE_FORMAT environment variable. This variable will 
generally contain one or more field names, each denoted by a dollar sign andcurly braces, 
showing where the log message data should be inserted. The default format is equivalent to:<br>

    [${severity}] [${time}]: ${message}<br>

This format is probably suitable for most uses, but there are a few other fields that might
be useful:Í4<br>

* First item To insert details about the source code location from which the message was generated, use some combination of the ${file}, ${line}, and ${function} fields.<br>
* Second item To insert the name of the node that generated the log message, use the ${node} field<br>

obs: tenho que deixar o fundo rosa
The roslaunch tool (which we’ll introduce in Chapter 6) does not, by default, funnel
standard output and standard error from the nodes it launches to its own output
streams. To see output from a roslaunched node, you must explicitly use the output="screen" attribute, or force all nodes to have this attribute with the --screen
command-line parameter to roslaunch. See page 88.

## **4.4.2 Messages on rosout**

In addition to appearing on the console, every log message is also published on the topic
/rosout. The message type of this topic is rosgraph_msgs/Log. Listing 4.6 shows the
fields in this data type, which includes the severity level, the message itself, and some other
associated metadata.<br>

You might notice that the information in each of these messages is quite similar to
the details in the console output discussed above. The primary usefulness of the /rosout
topic, compared to the console output, is that it includes, in a single stream, log messages
from every node in the system. All of those log messages show up on /rosout, regardless
of where, when, or how their nodes were started, or even which computer they’re running
on.<br>

Since /rosout is just an ordinary topic, you could, of course, use

**4. LOG MESSAGES**
_______<br><br>

_______
_______
1 byte DEBUG=1
2 byte INFO=2
3 byte WARN=4
4 byte ERROR=8
5 byte FATAL=16
6 std_msgs / Header he ade r
7 ui n t 3 2 se q
8 time stamp
9 s t r i n g frame_id
10 byte l e v e l
11 s t r i n g name
12 s t r i n g msg
13 s t r i n g f i l e
14 s t r i n g f u n c ti o n
15 ui n t 3 2 l i n e
16 s t r i n g [ ] t o p i c s
_________
_________
                                                       ** Listing 4.6**: Fields in the rosgraph_msgs/Log message type.

    rostopic echo /rosout<br>
 
to see the messages directly. If you insist, could even write a program of your own to subscribe to /rosout and display or process the messages however you like. However, the
simplest way to see /rosout messages is to use this command:Í5Í6<br>

        rqt_console<br>
        
Figure 4.2 depicts the resulting GUI. It shows log messages from all nodes, one per line,
along with options to hide or highlight messages based on various kinds of filters. The GUI
itself should not need any extra explanation.<br>

Obs: deixar fundo azul 
- The description of rqt_console above is not quite true. In fact, rqt_console subscribes to /rosout_agg instead of /rosout. Here’s the true graph, when both our
count example and an instance of rqt_console are running:

__________________________________________________________________________________________________________________________________________________________________
Í5http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch
Í6http://wiki.ros.org/rqt_console


obs: add imagem aqui 

```
/The _agg suffix refers to the fact that messages are aggregated by the rosout node.
/Every message published on the /rosout topic is echoed on the /rosout_agg topic
/by the rosout node.
/The reason for this apparent redundancy is to reduce the overhead of debugging.
/Because each publisher-subscriber relationship leads to a direct network connection between the two nodes, subscribing to /rosout (for which every node is a/
/publisher) can be costly on systems with many nodes, especially when those nodes
/generate many log messages. The idea is that the rosout node will be the only subscriber to /rosout and the only publisher on /rosout_agg. Then debugging tools
/can access the complete stream of log messages, without creating extra work for
/every node in the system, by subscribing to /rosout_agg.
/As an aside, ROS packages for some robots, including the PR2 and the TurtleBot,
/use the same pattern for diagnostic messages, which are originally published on a
/topic called /diagnostics and echoed by an aggregator node on another topic called
/diagnostics_agg.
```<br>

## **4.4.3 Log files**<br>
The third and final destination for log messages is a log file generated by the rosout node.
As part of its callback function for the /rosout topic, this node writes a line to a file with a
name like this:

```∼/.ros/log/run_id/rosout.log ```

This rosout.log log file is a plain text file. It can be viewed with command line tools like
less, head, or tail, or with your favorite text editor. The run_id is a universally-unique
identifier (UUID) which is generated—based on your computer’s hardware MAC address
and the current time—when the master is started. Here’s an example run_id:<br>

57aa1860-d765-11e2-a830-f0def1e189cc

The use of this sort of unique identifier makes it possible to distinguish logs from separate
ROS sessions.<br>

**Finding** the run id There at least two easy ways to learn the run_id of the current session.
- You can examine the output generated by roscore. Near the end of this output, you’ll
see a line that looks something like this.

<p setting /run_id to run_id>

- You can ask the master for the current run_id, using a command like this:

<p rosparam get /run_id>

<p>This works because the run_id is stored on the parameter server. More details about
parameters are in Chapter 7.

**Checkin and purging log files** These log files accumulate over time, which can be problematic if you use ROS for a while on a system that has meaningful limitations (due either
to an account quota or to hardware limits) on disk space. Both roscore and roslaunch perform checks to monitor the size of existing logs, and warn you when they exceed 1GB, but
neither will take any steps to reduce the size. You can use this command to see the amount
of disk space in the current user account consumed by ROS logs:Í7

<p rosclean check>
___

If the logs are consuming too much disk space, you can remove all of the existing logs using
this command:<br>
<p rosclean purge><br>
You can also, if you prefer, delete the log files by hand.<br>












  
